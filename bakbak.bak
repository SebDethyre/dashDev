#include <gtk/gtk.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/file.h> 
#include <sys/wait.h> 
#include <glib.h>
#include <gdk/gdk.h>
#include <unistd.h>
#include <fcntl.h>
#include <signal.h>

#include "include/fileman.h"
#include "include/launching.h"

#define LOCK_FILE "/tmp/my_program.lock"

gint window_width;
gint number_of_devs;
gint basic_height; 
gint intern_minal_height; 

gulong key_press_handler_id;
gulong key_press_handler_id_right;
gulong key_press_handler_id_B;
int current_index = -1;

GtkWidget *check_vs, *check_ti, *check_job, *check_app, *check_init, *commit_window, *menu = NULL, *combobox, *counter_label;
GtkWidget *output_text_view = NULL;
GtkWindow *window;
static GtkWidget *popup = NULL;
// GtkWidget *window;
GtkWidget *scrolled_window;
GtkButton  *terminal_button;
//üì∫
const gchar* array_du_select_L[] = { "üìã     Logs", "üìà     Jenkins", "üìä     Infos", "üìâ     Fails", "üì∞     Output","üìë     Ticket", "üì∫     Apache ","üÜï     Nouveau", "üîÑ     Appli Init"};
const int num_options_L = sizeof(array_du_select_L) / sizeof(array_du_select_L[0]);

const gchar* array_du_select_R[] = { "üåÄ     Meld", "üìù     Commit", "üì©     Up", "üîÄ     Merge", "üóë     Delete", "üî¨     Modifi√©s", "üìü     Statut", "üë•     Diff", "üìí     SVN Log", "üìù     D.commit" };
const int num_options_R = sizeof(array_du_select_R) / sizeof(array_du_select_R[0]);

const gchar* array_du_select_V[] = { "üìà     Jenkins", "üåÄ     Meld", "üìë     Ticket", "üìã     Logs", "üÜï     Nouveau", "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ", "üì©     Up", "üìù     Commit", "üîÄ     Merge", "üî¨     Modifi√©s", "üìü     Statut", "üë•     Diff" };
const int num_options_V = sizeof(array_du_select_V) / sizeof(array_du_select_V[0]);

// const gchar* array_du_select_B[] = {"‚ñ≤", "Jenkins", "Ticket", "Application", "Logs", "Test", "Choix test" };
// const int num_options_B = sizeof(array_du_select_B) / sizeof(array_du_select_B[0]);

typedef struct {
    gint index;
    GtkTreeView *treeview;
} MenuItemData;

gchar *selected_filename;
gboolean terminal_open = FALSE;

bool is_instance_running() {
    int lock_fd = open(LOCK_FILE, O_CREAT | O_RDWR, 0666);
    if (lock_fd == -1) {
        perror("Could not open lock file");
        exit(EXIT_FAILURE);
    }
    int lock_result = flock(lock_fd, LOCK_EX | LOCK_NB);
    if (lock_result == -1) {
        close(lock_fd);
        return true;
    }
    return false;
}

void toggle_intern_minal_height(GtkWidget *widget, GtkWidget *scrolled_window) {
    if (terminal_open) {
        gtk_widget_hide(scrolled_window);
        gtk_button_set_label(terminal_button, "‚ñº");
        terminal_open = FALSE;
    }
    else {
        gtk_widget_show(scrolled_window);
        gtk_widget_set_size_request(scrolled_window, -1, 300);
        gtk_button_set_label(terminal_button, "‚ñ≤");
        terminal_open = TRUE;
    }
}

void toggle_window_height_at_bottom(GtkWidget *widget, GtkWindow *window) {
    if (!terminal_open) {
        gtk_window_resize(window, window_width, basic_height);
        terminal_open = FALSE;
    }
    else {
        gtk_window_resize(window, window_width, basic_height + 300);
        terminal_open = TRUE;
    }
}

void grow_intern_minal() {
    gtk_window_resize(GTK_WINDOW(window), window_width, basic_height + 300);
    gtk_widget_show(scrolled_window);
    gtk_widget_set_size_request(GTK_WIDGET(scrolled_window), -1, 300);
    gtk_button_set_label(terminal_button, "‚ñ≤");
    terminal_open = TRUE;
}

void shrink_intern_minal() {
    gtk_window_resize(GTK_WINDOW(window), window_width , basic_height);
    gtk_widget_hide(scrolled_window);
    gtk_button_set_label(terminal_button, "‚ñº");
    terminal_open = FALSE;
}

gchar* recuperer_elements_droite_string(const char* fichier, const char* chaine) {
    FILE* file = fopen(fichier, "r");
    if (file == NULL) {
        fprintf(stderr, "Failed to open file: %s\n", fichier);
        return NULL;
    }
    char ligne[256];
    gchar* mots = NULL;
    while (fgets(ligne, sizeof(ligne), file)) {
        if (strstr(ligne, chaine)) {
            // Trouver l'index de la cha√Æne "chaine" dans la ligne
            char* index = strstr(ligne, chaine);
            // Avancer l'index jusqu'au caract√®re suivant "chaine"
            index += strlen(chaine);
            // Copier la valeur de droite dans la variable "mots"
            mots = strdup(index);
            break;
        }
    }
    if (mots == NULL) return NULL;
    fclose(file);
    return mots;
}

gchar* escape_quotes(const gchar* input) {
    GString *output = g_string_new(NULL);
    const gchar *p = input;
    while (*p) {
        if (*p == '\'') g_string_append(output, "'\\''");
        else g_string_append_c(output, *p);
        p++;
    }
    return g_string_free(output, FALSE);
}

void save_current_dev(GtkTreeView *treeview) {
    gchar *index_temp = g_strdup_printf("current_dev:%d", current_index);
    replace_line("/home/sdethyre/sandbox/dash_dev_boisson/config.txt", "current_dev:", index_temp);
}

gboolean on_treeview_button_press(GtkWidget *widget, GdkEventButton *event, gpointer user_data) {
    if (event->button == GDK_BUTTON_PRIMARY) { // Clic gauche
        gtk_widget_hide(GTK_WIDGET(user_data));
        return TRUE;
    }
    return FALSE;
}

gboolean on_stdout_output(GIOChannel *channel, GIOCondition condition, gpointer data) {
    if (!GTK_IS_TEXT_BUFFER(data)) {
        g_warning("on_stdout_output: Invalid data type. Expected GtkTextBuffer.");
        return FALSE;
    }

    GtkTextBuffer *buffer = GTK_TEXT_BUFFER(data);
    gchar *line = NULL;
    gsize length = 0;

    // Lire une ligne de la sortie standard
    if (g_io_channel_read_line(channel, &line, &length, NULL, NULL) == G_IO_STATUS_NORMAL) {
        // Mettre √† jour le widget GtkTextView avec la ligne lue
        GtkTextIter end;
        gtk_text_buffer_get_end_iter(buffer, &end);
        gtk_text_buffer_insert(buffer, &end, line, length);
        g_free(line);
        // Faire d√©filer le GtkTextView vers le bas pour afficher la derni√®re sortie
        GtkAdjustment *v_adjust = gtk_scrollable_get_vadjustment(GTK_SCROLLABLE(GTK_TEXT_VIEW(output_text_view)));

        if (v_adjust) gtk_adjustment_set_value(v_adjust, gtk_adjustment_get_upper(v_adjust) - gtk_adjustment_get_page_size(v_adjust));
    }
    // Continuer √† surveiller la sortie standard
    return TRUE;
}

void execute_bash_intern(GtkWidget *widget, gpointer data, gchar *command) {
    GtkWidget *output_text_view = GTK_WIDGET(data);
    // Get the GtkTextBuffer associated with the GtkTextView
    GtkTextBuffer *output_text_buffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(output_text_view));
    // Clear the GtkTextView before executing the command
    gtk_text_buffer_set_text(output_text_buffer, "", -1);
    // Create the final command to be executed
    gchar *final_command = g_strdup_printf("bash -c \"%s\"", command);

    // Set up the GIOChannels to monitor the standard output and error
    GPid pid;
    GIOChannel *stdout_channel = NULL;
    GIOChannel *stderr_channel = NULL;
    GError *error = NULL;
    int stdout_fd, stderr_fd;

    gboolean success = g_spawn_async_with_pipes(
        NULL,               // working directory
        (gchar *[]){"/bin/bash", "-c", final_command, NULL},
        NULL,               // environment
        G_SPAWN_SEARCH_PATH | G_SPAWN_DO_NOT_REAP_CHILD,
        NULL,               // child setup function
        NULL,               // user data
        &pid,               // child PID
        NULL,               // standard input
        &stdout_fd,         // standard output (file descriptor)
        &stderr_fd,         // standard error (file descriptor)
        &error              // error
    );
    g_free(final_command);
    if (success) {
        // Convert file descriptors to GIOChannels
        stdout_channel = g_io_channel_unix_new(stdout_fd);
        stderr_channel = g_io_channel_unix_new(stderr_fd);
        // Connect the on_stdout_output function to monitor the standard output
        g_io_add_watch(stdout_channel, G_IO_IN, on_stdout_output, output_text_buffer);
        g_io_add_watch(stderr_channel, G_IO_IN, on_stdout_output, output_text_buffer); // Add watch for stderr too

        g_io_channel_unref(stdout_channel);
        g_io_channel_unref(stderr_channel);
    } 
    else g_error_free(error);
}

void show_commit_dialog(GtkTreeView *treeview, GtkWidget *widget, gpointer user_data) {
    GtkWidget *dialog = gtk_dialog_new_with_buttons("Commit", GTK_WINDOW(commit_window),
                                                    GTK_DIALOG_MODAL,
                                                    "Valider", GTK_RESPONSE_ACCEPT,
                                                    "Annuler", GTK_RESPONSE_CANCEL,
                                                    NULL);
    // D√©finir la largeur souhait√©e de la fen√™tre de dialogue
    gtk_window_set_default_size(GTK_WINDOW(dialog), 800, -1);
    // Permettre le redimensionnement de la fen√™tre de dialogue
    gtk_window_set_resizable(GTK_WINDOW(dialog), TRUE);
    GtkWidget *content_area = gtk_dialog_get_content_area(GTK_DIALOG(dialog));

    // Cr√©er une entr√©e pour le message de commit et d√©finir la largeur
    GtkWidget *commit_entry = gtk_entry_new();
    gtk_entry_set_placeholder_text(GTK_ENTRY(commit_entry), "Entrez votre message de commit ici...");
    gtk_entry_set_width_chars(GTK_ENTRY(commit_entry), 40);
    gtk_container_add(GTK_CONTAINER(content_area), commit_entry);
    gtk_widget_show_all(content_area);

    GtkTreeSelection *selection = gtk_tree_view_get_selection(treeview);
    GtkTreeModel *model;
    GtkTreeIter iter;
    gchar *full_text;

    if (gtk_tree_selection_get_selected(selection, &model, &iter)) gtk_tree_model_get(model, &iter, 1, &full_text, -1);
    
    gint response = gtk_dialog_run(GTK_DIALOG(dialog));
    if (response == GTK_RESPONSE_ACCEPT) {
        const gchar *commit_message = gtk_entry_get_text(GTK_ENTRY(commit_entry));

        if (full_text && !g_str_has_suffix(full_text, ".bak")) {
            gchar *local_path = g_strdup_printf("/home/sdethyre/public_html/openads/%s", full_text);
            gchar *commit_file_path = g_build_filename("/home/sdethyre/sandbox/dash_dev_boisson/commit_message.txt", NULL);
            FILE *commit_file = fopen(commit_file_path, "w");
            if (commit_file) {
                fprintf(commit_file, "%s", commit_message);
                fclose(commit_file);
            }
            else {
                g_print("Failed to create commit message file.\n");
                g_free(local_path);
                g_free(commit_file_path);
                gtk_widget_destroy(dialog);
                return;
            }
            gchar *escaped_commit_message = g_shell_quote(commit_message);
            gchar *svn_command = g_strdup_printf("svn commit --file %s %s > /home/sdethyre/sandbox/dash_dev_boisson/svn_output.txt", commit_file_path, local_path);

            FILE *svn_output = popen(svn_command, "r");
            if (svn_output) {
                char buffer[128];
                while (fgets(buffer, sizeof(buffer), svn_output) != NULL) printf("%s", buffer);
                
                int pclose_result = pclose(svn_output);
                if (pclose_result == 0) {
                    g_print("Commit r√©ussi !\n");
                    // Read the output of svn_output.txt
                    char *line = NULL;
                    size_t buffer_size = 0;
                    ssize_t read;
                    gchar *to_copy = NULL;
                    FILE *file = fopen("/home/sdethyre/sandbox/dash_dev_boisson/svn_output.txt", "r");
                    if (file) {   
                        gchar *output_lines = g_strdup("");
                        while ((read = getline(&line, &buffer_size, file)) != -1) {
                            gchar *escaped_line = escape_quotes(line);
                            gchar *cmd_show_line = g_strdup_printf("echo '%s'; ", escaped_line);
                            output_lines = g_strconcat(output_lines, cmd_show_line, NULL);

                            // Check if the line contains "R√©vision" and "propag√©e"
                            char *revision_str = "R√©vision ";
                            char *propagated_str = " propag√©e.";
                            char *revision_start = strstr(line, revision_str);
                            char *propagated_end = strstr(line, propagated_str);
                            if (revision_start != NULL && propagated_end != NULL) {
                                // Extract the part of the line containing the revision number
                                char *revision_number_start = revision_start + strlen(revision_str);
                                size_t revision_number_length = propagated_end - revision_number_start;
                                char *revision_number = (char *)malloc(revision_number_length + 1);
                                strncpy(revision_number, revision_number_start, revision_number_length);
                                revision_number[revision_number_length] = '\0';

                                int revision = atoi(revision_number);
                                printf("Num√©ro de r√©vision : %d\n", revision);
                                // to_copy = g_strdup_printf("-r%d : %s; %s", revision, commit_message, read_command);
                                to_copy = g_strdup_printf("-r%d : %s", revision, commit_message);

                                free(revision_number);
                                fclose(file);
                                break;
                            }
                        }
                        gchar *escaped_to_copy = escape_quotes(to_copy);
                        // gchar *cmd_show_all_lines = g_strdup_printf("gnome-terminal -- bash -c \"cat /home/sdethyre/sandbox/dash_dev_boisson/svn_output.txt; echo '\n\n%s\n'; read -s -r -p 'Appuyez sur Entr√©e pour fermer le terminal...'\"", escaped_to_copy);
                        gchar *cmd_interne = g_strdup_printf("cat /home/sdethyre/sandbox/dash_dev_boisson/svn_output.txt; echo '\n\n%s\n'", escaped_to_copy);
                        grow_intern_minal();
                        execute_bash_intern(widget, output_text_view, cmd_interne);

                        g_free(output_lines);
                        g_free(line);
                        // remove("/home/sdethyre/sandbox/dash_dev_boisson/svn_output.txt");

                        g_free(escaped_to_copy);
                        g_free(to_copy);
                    }
                }
                else g_print("Failed to execute svn commit.\n");
            }
            else  g_print("Failed to execute svn commit.\n");
            
            g_free(local_path);
            g_free(commit_file_path);
            g_free(svn_command);
            g_free(escaped_commit_message);
        }
    }
    gtk_widget_destroy(dialog); 
}

void delete_branch(GtkTreeView *treeview, GtkWidget *widget, gpointer user_data) {
    GtkTreeSelection *selection = gtk_tree_view_get_selection(treeview);
    GtkTreeModel *model;
    GtkTreeIter iter;
    gchar *full_text;

    if (gtk_tree_selection_get_selected(selection, &model, &iter)) gtk_tree_model_get(model, &iter, 1, &full_text, -1);
    if (full_text && !g_str_has_suffix(full_text, ".bak")) {
         GtkWidget *dialog = gtk_message_dialog_new(
            GTK_WINDOW(widget),
            GTK_DIALOG_MODAL,
            GTK_MESSAGE_QUESTION,
            GTK_BUTTONS_YES_NO,
            "√ätes-vous s√ªr de vouloir supprimer la branche %s?",
            full_text
        );

        gtk_window_set_title(GTK_WINDOW(dialog), "Confirm Delete");

        gint result = gtk_dialog_run(GTK_DIALOG(dialog));
        gtk_widget_destroy(dialog);

        if (result != GTK_RESPONSE_YES) {
            // User chose not to delete the branch, return without doing anything
            return;
        }
        gchar *directory = g_strdup_printf("/home/sdethyre/public_html/openads");
        if (chdir(directory) != 0) {
            g_print("Impossible de changer de r√©pertoire.\n");
            g_free(directory);
            return;
        }
        gchar *svn_command = g_strdup_printf("svn delete svn+ssh://sdethyre@scm.adullact.net/svn/openfoncier/branches/%s -m \"chore(branch): suppression de la branche de d√©veloppement %s\" > /home/sdethyre/sandbox/dash_dev_boisson/svn_output.txt", full_text, full_text);

        FILE *svn_output = popen(svn_command, "r");
        if (svn_output) {
            char buffer[128];
            while (fgets(buffer, sizeof(buffer), svn_output) != NULL) printf("%s", buffer);
            
            int pclose_result = pclose(svn_output);
            if (pclose_result == 0) {
                g_print("Delete r√©ussi !\n");

                // Read the output of svn_output.txt
                char *line = NULL;
                size_t buffer_size = 0;
                ssize_t read;
                gchar *to_copy = NULL;
                FILE *file = fopen("/home/sdethyre/sandbox/dash_dev_boisson/svn_output.txt", "r");
                if (file) {   
                    gchar *output_lines = g_strdup("");
                    while ((read = getline(&line, &buffer_size, file)) != -1) {
                        gchar *escaped_line = escape_quotes(line);
                        gchar *cmd_show_line = g_strdup_printf("echo '%s'; ", escaped_line);
                        output_lines = g_strconcat(output_lines, cmd_show_line, NULL);

                        // Check if the line contains "R√©vision" and "propag√©e"
                        char *revision_str = "R√©vision ";
                        char *propagated_str = " propag√©e.";
                        char *revision_start = strstr(line, revision_str);
                        char *propagated_end = strstr(line, propagated_str);
                        if (revision_start != NULL && propagated_end != NULL) {
                            // Extract the part of the line containing the revision number
                            char *revision_number_start = revision_start + strlen(revision_str);
                            size_t revision_number_length = propagated_end - revision_number_start;
                            char *revision_number = (char *)malloc(revision_number_length + 1);
                            strncpy(revision_number, revision_number_start, revision_number_length);
                            revision_number[revision_number_length] = '\0';

                            int revision = atoi(revision_number);
                            printf("Num√©ro de r√©vision : %d\n", revision);
                            // to_copy = g_strdup_printf("-r%d : %s; %s", revision, commit_message, read_command);
                            gchar *delete_message = g_strdup_printf("chore(branch): suppression de la branche de d√©veloppement %s", full_text);
                            to_copy = g_strdup_printf("-r%d : %s", revision, delete_message);

                            free(revision_number);
                            fclose(file);
                            break;
                        }
                    }
                    
                    gchar *escaped_to_copy = escape_quotes(to_copy);
                    // gchar *cmd_show_all_lines = g_strdup_printf("gnome-terminal -- bash -c \"cat /home/sdethyre/sandbox/dash_dev_boisson/svn_output.txt; echo '\n\n%s\n'; read -s -r -p 'Appuyez sur Entr√©e pour fermer le terminal...'\"", escaped_to_copy);
                    gchar *cmd_interne = g_strdup_printf("cat /home/sdethyre/sandbox/dash_dev_boisson/svn_output.txt; echo '\n\n%s\n'", escaped_to_copy);
                    grow_intern_minal();
                    execute_bash_intern(widget, output_text_view, cmd_interne);

                    g_free(output_lines);
                    g_free(line);
                    // remove("/home/sdethyre/sandbox/dash_dev_boisson/svn_output.txt");
                    g_free(escaped_to_copy);
                    g_free(to_copy);
                }
            }
            else g_print("Failed to execute svn commit.\n");
            
        }
        else g_print("Failed to execute svn commit.\n");
        g_free(svn_command);
    }
}

void launch_terminal(GtkTreeView *treeview, GtkWidget *widget, gpointer data, gchar *command, gchar *how_to_close) {
    GtkTreeSelection *selection = gtk_tree_view_get_selection(treeview);
    GtkTreeModel *model;
    GtkTreeIter iter;
    if (gtk_tree_selection_get_selected(selection, &model, &iter))
    {
        gchar *full_text;
        gtk_tree_model_get(model, &iter, 1, &full_text, -1);

        if (full_text && !g_str_has_suffix(full_text, ".bak")) {
            gchar *directory = g_strdup_printf("/home/sdethyre/public_html/openads/%s", full_text);

            if (chdir(directory) != 0) {
                g_print("Impossible de changer de r√©pertoire.\n");
                g_free(directory);
                return;
            }
            gchar *final_command;
            if(strcmp(how_to_close, "merge") == 0) {
                GError *error = NULL;
                gchar *command_line[] = { "/bin/bash", "-c", "/home/sdethyre/sandbox/merge/./merge", NULL };
                if (!g_spawn_async(NULL, command_line, NULL, G_SPAWN_SEARCH_PATH, NULL, NULL, NULL, &error)) {
                    g_print("Erreur lors de l'ex√©cution du script : %s\n", error->message);
                    g_error_free(error);
                }
                return;
            } 
            if(strcmp(how_to_close, "intern_minal") == 0) {
                grow_intern_minal();
                execute_bash_intern(widget, output_text_view, command); 
                return;
            } 
            if (strcmp(how_to_close, "return_key") == 0)  final_command = g_strdup_printf("gnome-terminal -- bash -c '%s; read -s -r -p \"Appuyez sur Entr√©e pour fermer le terminal...\"'", command);
            
            else if(strcmp(how_to_close, "any_key") == 0) final_command = g_strdup_printf("gnome-terminal -- bash -c '%s; read -n 1 -p \"Appuyez sur une touche pour fermer le terminal...\"'", command);
            else final_command = g_strdup_printf("gnome-terminal -- bash -c '%s'", command);
            g_spawn_command_line_async(final_command, NULL);
            shrink_intern_minal();
            g_free(directory);
        }
        if (full_text) g_free(full_text);
    }
}

static void on_popup_close(GtkWidget *widget, gpointer user_data) {
    gtk_widget_destroy(popup);
    popup = NULL;
}

static void on_popup_destroy(GtkWidget *widget, gpointer user_data) {
    popup = NULL;
}

void create_popup_info(GtkTreeView *treeview) {
    GtkTreeSelection *selection = gtk_tree_view_get_selection(treeview);
    GtkTreeModel *model;
    GtkTreeIter iter;
    gchar *full_text;

    if (gtk_tree_selection_get_selected(selection, &model, &iter))
        gtk_tree_model_get(model, &iter, 1, &full_text, -1);

    if (full_text && !g_str_has_suffix(full_text, ".bak")) {
        popup = gtk_window_new(GTK_WINDOW_TOPLEVEL);
        gchar *titre = g_strdup_printf("Infos sur %s", full_text);
        gtk_window_set_title(GTK_WINDOW(popup), titre);
        gtk_window_set_position(GTK_WINDOW(popup), GTK_WIN_POS_CENTER);
        gtk_window_set_default_size(GTK_WINDOW(popup), 400, 200);

        GtkWidget *box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 10);
        gtk_container_add(GTK_CONTAINER(popup), box);

        gchar directory[256] = "/home/sdethyre/public_html/openads/";
        gchar file_path[512];
        snprintf(file_path, sizeof(file_path), "%s%s", directory, full_text);
        // Count modified files using svn status
        int count = count_modified_files(file_path);
        gchar *modified = g_strdup_printf("Modifi√©s : %d", count); 
        GtkWidget *modified_label = gtk_label_new(modified);
        gtk_widget_set_margin_top(modified_label, 20); 
        gtk_box_pack_start(GTK_BOX(box), modified_label, TRUE, TRUE, 0);

        gchar *command = g_strdup_printf("python3 /home/sdethyre/sandbox/dash_dev_boisson/fails.py %s", full_text);
        FILE *fp = popen(command, "r");
        if (fp == NULL) {
            g_free(command);
            // return TRUE;
        }
        char buffer[128];
        GString *output = g_string_new(NULL);  
        while (fgets(buffer, sizeof(buffer), fp) != NULL) {
            g_string_append(output, buffer);
        }
        pclose(fp);
        g_free(command);
        g_strstrip(output->str);    // Supprimer les espaces de d√©but et de fin
        g_strchomp(output->str);                

        if (strcmp(output->str, "Job inexistant : erreur 404") == 0) {
            GtkWidget *output_label = gtk_label_new(output->str);  
            gtk_box_pack_start(GTK_BOX(box), output_label, TRUE, TRUE, 0);
        }
        else if (strcmp(output->str, "Dernier job incomplet") == 0) {
            GtkWidget *output_label = gtk_label_new(output->str);  
            gtk_box_pack_start(GTK_BOX(box), output_label, TRUE, TRUE, 0);
            gchar *command_2 = g_strdup_printf("python3 /home/sdethyre/sandbox/dash_dev_boisson/count_display_fails.py %s", full_text);
            FILE *fp_2 = popen(command_2, "r");
            if (fp_2 == NULL) {
                g_free(command_2);
                // return TRUE;
            }
            char buffer_2[128];
            GString *output_2 = g_string_new(NULL);  
            while (fgets(buffer_2, sizeof(buffer_2), fp_2) != NULL) {
                g_string_append(output_2, buffer_2);
            }
            pclose(fp_2);
            g_free(command_2);
            GtkWidget *output_label_2 = gtk_label_new(output_2->str);  
            gtk_box_pack_start(GTK_BOX(box), output_label_2, TRUE, TRUE, 0);
            g_string_free(output_2, TRUE);

            gchar *command_4 = g_strdup_printf("python3 /home/sdethyre/sandbox/dash_dev_boisson/percent_by_line.py %s", full_text);
            FILE *fp_4 = popen(command_4, "r");
            if (fp_4 == NULL) {
                g_free(command_4);
                // return TRUE;
            }
            char buffer_4[128];
            GString *output_4 = g_string_new(NULL);  
            while (fgets(buffer_4, sizeof(buffer_4), fp_4) != NULL) {
                g_string_append(output_4, buffer_4);
            }
            pclose(fp_4);
            g_free(command_4);
            GtkWidget *output_label_4 = gtk_label_new(output_4->str);  
            gtk_box_pack_start(GTK_BOX(box), output_label_4, TRUE, TRUE, 0);
            g_string_free(output_4, TRUE);
        }
        else if (strcmp(output->str, "Job en cours") == 0) {
            GtkWidget *inter_line = gtk_label_new("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ");  
            gtk_box_pack_start(GTK_BOX(box), inter_line, TRUE, TRUE, 0);
            GtkWidget *output_label = gtk_label_new(output->str);  
            gtk_box_pack_start(GTK_BOX(box), output_label, TRUE, TRUE, 0);
            gchar *command_2 = g_strdup_printf("python3 /home/sdethyre/sandbox/dash_dev_boisson/count_display_fails.py %s", full_text);
            FILE *fp_2 = popen(command_2, "r");
            if (fp_2 == NULL) {
                g_free(command_2);
                // return TRUE;
            }
            char buffer_2[128];
            GString *output_2 = g_string_new(NULL);  
            while (fgets(buffer_2, sizeof(buffer_2), fp_2) != NULL) {
                g_string_append(output_2, buffer_2);
            }
            pclose(fp_2);
            g_free(command_2);
            GtkWidget *output_label_2 = gtk_label_new(output_2->str);  
            gtk_box_pack_start(GTK_BOX(box), output_label_2, TRUE, TRUE, 0);
            g_string_free(output_2, TRUE);
            
            gchar *command_3 = g_strdup_printf("python3 /home/sdethyre/sandbox/dash_dev_boisson/percent.py %s", full_text);
            FILE *fp_3 = popen(command_3, "r");
            if (fp_3 == NULL) {
                g_free(command_3);
                // return TRUE;
            }
            char buffer_3[128];
            GString *output_3 = g_string_new(NULL);  
            while (fgets(buffer_3, sizeof(buffer_3), fp_3) != NULL) {
                g_string_append(output_3, buffer_3);
            }
            pclose(fp_3);
            g_free(command_3);
            
            GtkWidget *output_label_3 = gtk_label_new(output_3->str);  
            gtk_box_pack_start(GTK_BOX(box), output_label_3, TRUE, TRUE, 0);
            g_string_free(output_3, TRUE);
            
            gchar *command_4 = g_strdup_printf("python3 /home/sdethyre/sandbox/dash_dev_boisson/percent_by_line.py %s", full_text);
            FILE *fp_4 = popen(command_4, "r");
            if (fp_4 == NULL) {
                g_free(command_4);
                // return TRUE;
            }
            char buffer_4[128];
            GString *output_4 = g_string_new(NULL);  
            while (fgets(buffer_4, sizeof(buffer_4), fp_4) != NULL) {
                g_string_append(output_4, buffer_4);
            }
            pclose(fp_4);
            g_free(command_4);
            
            GtkWidget *output_label_4 = gtk_label_new(output_4->str);  
            gtk_box_pack_start(GTK_BOX(box), output_label_4, TRUE, TRUE, 0);
            g_string_free(output_4, TRUE);
        }
        else {
            GtkWidget *inter_line = gtk_label_new("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ");  
            gtk_box_pack_start(GTK_BOX(box), inter_line, TRUE, TRUE, 0);
            GtkWidget *output_label = gtk_label_new(output->str);  
            gtk_box_pack_start(GTK_BOX(box), output_label, TRUE, TRUE, 0);
            
            GtkWidget *output_label_3 = gtk_label_new("Job achev√© √† 100%");  
            gtk_box_pack_start(GTK_BOX(box), output_label_3, TRUE, TRUE, 0);
        }
        g_string_free(output, TRUE);

        GtkWidget *button_box = gtk_button_box_new(GTK_ORIENTATION_HORIZONTAL);
        gtk_box_pack_start(GTK_BOX(box), button_box, TRUE, TRUE, 0);

        GtkWidget *close_button = gtk_button_new_with_label("Fermer");
        g_signal_connect(G_OBJECT(close_button), "clicked", G_CALLBACK(on_popup_close), NULL);
        gtk_container_add(GTK_CONTAINER(button_box), close_button);

        g_signal_connect(G_OBJECT(popup), "destroy", G_CALLBACK(on_popup_destroy), NULL);
        gtk_widget_show_all(popup);
    }
}

void on_menu_item_activate_L(GtkMenuItem *menu_item, gpointer user_data) {
    MenuItemData *data = (MenuItemData *)user_data;
    gint selected_option_index = data->index;
    GtkTreeView *treeview = data->treeview;
    GtkTreeSelection *selection = gtk_tree_view_get_selection(treeview);
    GtkTreeModel *model;
    GtkTreeIter iter;
    switch (selected_option_index) {
        case 0:
            launch_file(treeview, NULL, NULL, "/home/sdethyre/bin/atreal/./testLogs");
            break;
        case 1:
            open_web_page(treeview, user_data, "open_job.py", combobox);
            break;
        case 2:
            if (gtk_tree_selection_get_selected(selection, &model, &iter)) {
                create_popup_info(treeview);
            }
            break;
        case 3:
            if (gtk_tree_selection_get_selected(selection, &model, &iter)) {
                gchar *full_text;
                gtk_tree_model_get(model, &iter, 1, &full_text, -1);

                if (full_text && !g_str_has_suffix(full_text, ".bak")) {
                    gchar *fails = g_strdup_printf("python3 /home/sdethyre/sandbox/dash_dev_boisson/display_fails.py %s", full_text);
                    launch_terminal(treeview, NULL, NULL, fails, "intern_minal");
                }
            }
            break;
        case 4:
            if (gtk_tree_selection_get_selected(selection, &model, &iter)) {
                gchar *full_text;
                gtk_tree_model_get(model, &iter, 1, &full_text, -1);

                if (full_text && !g_str_has_suffix(full_text, ".bak")) {
                    gchar *fails = g_strdup_printf("python3 /home/sdethyre/sandbox/dash_dev_boisson/output_jenkins.py %s", full_text);
                    launch_terminal(treeview, NULL, NULL, fails, "intern_minal");
                }
            }
            break;
        case 5:
            open_web_page(treeview, user_data, "open_ti.py" , combobox);
            break;
        case 6:
            launch_terminal(treeview, NULL, NULL, "tail -f /var/log/apache2/error.log", "return_key");
            break;
        case 7:
            launch_file(treeview, NULL, NULL, "/home/sdethyre/sandbox/auto/./dev");
            break;
        case 8:
            open_web_page(treeview, user_data, "open_app.py", combobox);
            break;
        default:
            break;
    }
}

void generic_quit (GtkTreeView *treeview, const char *pidFilename) {
    save_current_dev(treeview);
    clear_file(pidFilename);
    gtk_main_quit();
}

void on_menu_item_activate_R(GtkMenuItem *menu_item, gpointer user_data) {
    MenuItemData *data = (MenuItemData *)user_data;
    gint selected_option_index = data->index;
    GtkTreeView *treeview = data->treeview;
    switch (selected_option_index) {
        case 0:
            launch_file(treeview, NULL, NULL, "meld .");
            break;
        case 1:
            show_commit_dialog(treeview, NULL, NULL);
            break;
        case 2:
            launch_terminal(treeview, NULL, NULL, "svn update", "intern_minal");
            break;
        case 3:
            launch_terminal(treeview, NULL, NULL, "", "merge");
            break;
        case 4:
            delete_branch(treeview, NULL, NULL);
            break;
        case 5:
            launch_terminal(treeview, NULL, NULL, "svn status --ignore-externals | grep '^M'| sed 's/^M//'", "intern_minal");
            break;
        case 6:
            launch_terminal(treeview, NULL, NULL, "svn st --ignore-externals", "intern_minal");
            break;
        case 7:
            launch_terminal(treeview, NULL, NULL, "svn diff", "return_key");
            break;
        case 8:
            launch_terminal(treeview, NULL, NULL, "svn log", "intern_minal");
            break;
        case 9:
            launch_terminal(treeview, NULL, NULL, "svn log -l 1", "intern_minal");
            break;
        default:
            break;
    }
}

void on_menu_item_activate_V(GtkMenuItem *menu_item, gpointer user_data) {
    MenuItemData *data = (MenuItemData *)user_data;
    gint selected_option_index = data->index;
    GtkTreeView *treeview = data->treeview;
    switch (selected_option_index) {
        case 0:
            open_web_page(treeview, user_data, "open_job.py", combobox);
            break;
        case 1:
            launch_file(treeview, NULL, NULL, "meld .");
            break;
        case 2:
            open_web_page(treeview, user_data, "open_ti.py" , combobox);
            break;
        case 3:
            launch_file(treeview, NULL, NULL, "/home/sdethyre/bin/atreal/./testLogs");
            break;
        case 4:
            launch_file(treeview, NULL, NULL, "/home/sdethyre/sandbox/auto/./dev");
            break;
        case 5:
            // Exit
            break;
        case 6:
            launch_terminal(treeview, NULL, NULL, "svn update", "intern_minal");
            break;
        case 7:
            show_commit_dialog(treeview, NULL, NULL);
            break;
        case 8:
            launch_terminal(treeview, NULL, NULL, "", "merge");
            break;
        case 9:
            launch_terminal(treeview, NULL, NULL, "svn status --ignore-externals | grep '^M'| sed 's/^M//'", "intern_minal");
            break;
        case 10:
            launch_terminal(treeview, NULL, NULL, "svn st --ignore-externals", "intern_minal");
            break;
        case 11:
            launch_terminal(treeview, NULL, NULL, "svn diff", "return_key");
            break;
        default:
            break;
    }
}

static gboolean on_right_click(GtkWidget *widget, GdkEventButton *event, gpointer user_data) {
    if (event->type == GDK_BUTTON_PRESS && event->button == GDK_BUTTON_SECONDARY) {
        const gchar *menu_items[] = {"Option 1", "Option 2", "Option 3", "Option 4"};
        GtkTreeView *treeview = GTK_TREE_VIEW(widget);
        // Obtenir les coordonn√©es du curseur au moment du clic droit
        gdouble x, y;
        gdk_event_get_coords((GdkEvent*)event, &x, &y);
        gint cx = (gint)x, cy = (gint)y;

        // Convertir les coordonn√©es du curseur en coordonn√©es de la fen√™tre du widget treeview
        GdkWindow *window = gtk_tree_view_get_bin_window(treeview);
        gint win_x, win_y;
        gdk_window_get_origin(window, &win_x, &win_y);
        cx -= win_x;
        cy -= win_y;
        // Obtenir le chemin de la ligne (√©l√©ment) sous le curseur
        GtkTreePath *path = NULL;
        GtkTreeViewColumn *column = NULL;
        gint cell_x, cell_y; // Ajout des coordonn√©es du GtkCellRenderer
        gtk_tree_view_get_path_at_pos(treeview, cx, cy, &path, &column, &cell_x, &cell_y);

        GtkWidget *menu = gtk_menu_new();
        for (int i = 0; i < G_N_ELEMENTS(menu_items); i++) {
            GtkWidget *menu_item = gtk_menu_item_new_with_label(menu_items[i]);
            gtk_menu_shell_append(GTK_MENU_SHELL(menu), menu_item);
        }
        if (path != NULL) {
            // S√©lectionner l'√©l√©ment sous le curseur sans d√©clencher de clic
            gtk_tree_view_set_cursor(treeview, path, NULL, FALSE);
            gtk_tree_path_free(path);
        return TRUE; // Indiquer que l'√©v√©nement a √©t√© trait√©

        }
        // gtk_tree_view_get_cursor(treeview, &path, NULL);
        menu = gtk_menu_new();
        for (int i = 0; i < num_options_V; i++) {
            GtkWidget *menu_item = gtk_menu_item_new_with_label(array_du_select_V[i]);
            // Cr√©er et peupler la structure de donn√©es personnalis√©e
            MenuItemData *data = g_new(MenuItemData, 1);
            data->index = i;
            data->treeview = treeview;
            // Connecter le signal "activate" et passer la structure de donn√©es personnalis√©e en tant que user_data
            g_signal_connect(menu_item, "activate", G_CALLBACK(on_menu_item_activate_V), data);
            gtk_menu_shell_append(GTK_MENU_SHELL(menu), menu_item);
        }
        gtk_widget_show_all(menu);
        gtk_menu_popup_at_pointer(GTK_MENU(menu), NULL);
    }
    return FALSE; // Indiquer que l'√©v√©nement n'a pas √©t√© trait√©
}



static GtkWidget *left_menu = NULL;
static GtkWidget *right_menu = NULL;

gboolean on_treeview_key_press_left(GtkWidget *widget, GdkEventKey *event, gpointer user_data) {
    // const char *pidFilename = "/home/sdethyre/sandbox/dash_dev_boisson/pid.txt";
    // GtkTreeView *treeview = GTK_TREE_VIEW(widget);
    switch (event->keyval) {
        case GDK_KEY_Right:
        {
            system("xdotool key Escape");
        }
    }
    return FALSE;
}
gboolean on_treeview_key_press_right(GtkWidget *widget, GdkEventKey *event, gpointer user_data) {
    // const char *pidFilename = "/home/sdethyre/sandbox/dash_dev_boisson/pid.txt";
    // GtkTreeView *treeview = GTK_TREE_VIEW(widget);
    switch (event->keyval) {
        case GDK_KEY_Left:
        {
            system("xdotool key Escape");
        }
    }
    return FALSE;
}
gboolean on_treeview_key_press(GtkWidget *widget, GdkEventKey *event, gpointer user_data) {
    const char *pidFilename = "/home/sdethyre/sandbox/dash_dev_boisson/pid.txt";
    GtkTreeView *treeview = GTK_TREE_VIEW(widget);
    switch (event->keyval) {
        case GDK_KEY_n:
            g_signal_handler_disconnect(treeview, key_press_handler_id);
            launch_file(treeview, NULL, NULL, "/home/sdethyre/sandbox/auto/./dev");
            key_press_handler_id = g_signal_connect(treeview, "key-press-event", G_CALLBACK(on_treeview_key_press), NULL);
            break;
        case GDK_KEY_ISO_Level3_Shift:
            g_signal_handler_disconnect(treeview, key_press_handler_id);
            launch_file(treeview, NULL, NULL, "/home/sdethyre/bin/easyTests/./testsDialog");
            key_press_handler_id = g_signal_connect(treeview, "key-press-event", G_CALLBACK(on_treeview_key_press), NULL);
            break;
        case GDK_KEY_space:
            g_signal_handler_disconnect(treeview, key_press_handler_id);
            open_file(treeview, user_data);
            open_web_page(treeview, user_data, "open_job.py", combobox);
            open_web_page(treeview, user_data, "open_ti.py" , combobox);
            open_web_page(treeview, user_data, "open_app.py", combobox);
            key_press_handler_id = g_signal_connect(treeview, "key-press-event", G_CALLBACK(on_treeview_key_press), NULL);
            generic_quit (treeview, pidFilename);
            break;
        case GDK_KEY_Return:
            g_signal_handler_disconnect(treeview, key_press_handler_id);
            open_file(treeview, user_data);
            key_press_handler_id = g_signal_connect(treeview, "key-press-event", G_CALLBACK(on_treeview_key_press), NULL);
            generic_quit (treeview, pidFilename);
            return TRUE;
            break;
        case GDK_KEY_Left:
        {
            g_signal_handler_disconnect(treeview, key_press_handler_id);
            // if (left_menu) {
            //     gtk_menu_popdown(GTK_MENU(left_menu));
            //     gtk_widget_destroy(left_menu);
            //     left_menu = NULL;
            // }
            GtkTreePath *path;
            gtk_tree_view_get_cursor(treeview, &path, NULL);

            left_menu = gtk_menu_new();
            g_signal_connect(left_menu, "key-press-event", G_CALLBACK(on_treeview_key_press_left), NULL);
            // key_press_handler_id_left = g_signal_connect(left_menu, "key-press-event", G_CALLBACK(on_treeview_key_press_L), NULL);
            for (int i = 0; i < num_options_L; i++) {
                GtkWidget *menu_item = gtk_menu_item_new_with_label(array_du_select_L[i]);
                // Cr√©er et peupler la structure de donn√©es personnalis√©e
                MenuItemData *data = g_new(MenuItemData, 1);
                data->index = i;
                data->treeview = treeview;
                // Connecter le signal "activate" et passer la structure de donn√©es personnalis√©e en tant que user_data
                g_signal_connect(menu_item, "activate", G_CALLBACK(on_menu_item_activate_L), data);
                gtk_menu_shell_append(GTK_MENU_SHELL(left_menu), menu_item);
            }
            // Afficher le menu de droite
            gtk_widget_show_all(left_menu);
            gtk_menu_popup_at_widget(GTK_MENU(left_menu), GTK_WIDGET(gtk_widget_get_toplevel(GTK_WIDGET(treeview))), GDK_GRAVITY_WEST, GDK_GRAVITY_EAST, NULL);
            // g_signal_handler_disconnect(left_menu, key_press_handler_id_left);
            key_press_handler_id = g_signal_connect(treeview, "key-press-event", G_CALLBACK(on_treeview_key_press), NULL);
            break;
        }
        case GDK_KEY_Right:
        {
            g_signal_handler_disconnect(treeview, key_press_handler_id);
            // if (left_menu) {
            //     gtk_menu_popdown(GTK_MENU(left_menu));
            //     gtk_widget_destroy(left_menu);
            //     left_menu = NULL;
            // }
            GtkTreePath *path;
            gtk_tree_view_get_cursor(treeview, &path, NULL);
            right_menu = gtk_menu_new();
            g_signal_connect(right_menu, "key-press-event", G_CALLBACK(on_treeview_key_press_right), NULL);
            for (int i = 0; i < num_options_R; i++) {
                GtkWidget *menu_item = gtk_menu_item_new_with_label(array_du_select_R[i]);
                // Cr√©er et peupler la structure de donn√©es personnalis√©e
                MenuItemData *data = g_new(MenuItemData, 1);
                data->index = i;
                data->treeview = treeview;
                // Connecter le signal "activate" et passer la structure de donn√©es personnalis√©e en tant que user_data
                g_signal_connect(menu_item, "activate", G_CALLBACK(on_menu_item_activate_R), data);
                gtk_menu_shell_append(GTK_MENU_SHELL(right_menu), menu_item);
            }
            gtk_widget_show_all(right_menu);
            gtk_menu_popup_at_widget(GTK_MENU(right_menu), GTK_WIDGET(gtk_widget_get_toplevel(GTK_WIDGET(treeview))), GDK_GRAVITY_EAST, GDK_GRAVITY_WEST, NULL);
            gtk_tree_path_free(path);
            // g_signal_handler_disconnect(treeview, key_press_handler_id_right);

            key_press_handler_id = g_signal_connect(treeview, "key-press-event", G_CALLBACK(on_treeview_key_press), NULL);
            break;
        }
        case GDK_KEY_Control_R:
            g_signal_handler_disconnect(treeview, key_press_handler_id);
            launch_test(treeview, NULL, NULL);
            key_press_handler_id = g_signal_connect(treeview, "key-press-event", G_CALLBACK(on_treeview_key_press), NULL);
            break;
        case GDK_KEY_less:
            g_signal_handler_disconnect(treeview, key_press_handler_id);
            open_web_page(treeview, user_data, "open_app_no_init.py", combobox);
            key_press_handler_id = g_signal_connect(treeview, "key-press-event", G_CALLBACK(on_treeview_key_press), NULL);
            break;
        case GDK_KEY_Escape:
            generic_quit (treeview, pidFilename);
            break;
        case GDK_KEY_x:
            g_signal_handler_disconnect(treeview, key_press_handler_id);
            if (GTK_IS_WIDGET(popup)) gtk_widget_destroy(popup);
            generic_quit (treeview, pidFilename);
            break;
        case GDK_KEY_w:
        {
            if (popup != NULL) break; // Un popup est d√©j√† affich√©, ne rien faire
            create_popup_info(treeview);
            
            break;
        }
        default:
            break;
    }
    return FALSE;
}

void update_counter_label(GtkTreeSelection *selection) {
    GtkTreeModel *model;
    GtkTreeIter iter;
    // Get the selected row
    if (gtk_tree_selection_get_selected(selection, &model, &iter)) {
        gchar *filename;
        gtk_tree_model_get(model, &iter, 1, &filename, -1);
        gchar directory[256] = "/home/sdethyre/public_html/openads/";
        gchar file_path[512];
        snprintf(file_path, sizeof(file_path), "%s%s", directory, filename);
        // Count modified files using svn status
        int count = count_modified_files(file_path);
        // Update the label text with the count
        gchar *label_text = g_strdup_printf("Modifi√©s : %d", count);
        // gtk_label_set_text(GTK_LABEL(counter_label), label_text);
        g_free(label_text);
        g_free(filename);
    }
}

// Cr√©ez une fonction pour g√©rer le signal "changed" de la s√©lection
static void on_selection_changed(GtkTreeSelection *selection, gpointer user_data) {
    GtkTreeModel *model;
    GtkTreeIter iter;
    // V√©rifier si une ligne est s√©lectionn√©e
    if (gtk_tree_selection_get_selected(selection, &model, &iter)) {
        GtkTreePath *path = gtk_tree_model_get_path(model, &iter);
        // Convertir le chemin en un indice d'it√©ration (index) dans le mod√®le
        int index = gtk_tree_path_get_indices(path)[0];
        // Lib√©rer la m√©moire du GtkTreePath
        gtk_tree_path_free(path);
        // Mettre √† jour la variable globale de l'index
        current_index = index;
    } 
    else current_index = -1; // Aucune ligne n'est s√©lectionn√©e, r√©initialiser l'index
}

gchar *escamote_line(const gchar *line, const gchar *text_changed)
{
    // Dupliquer la ligne originale
    gchar *escamoted_line = g_strdup(line);
    // Trouver la position de la premi√®re occurrence de "text_changed" dans la ligne
    gchar *text_changed_pos = strstr(escamoted_line, text_changed);
    // V√©rifier si l'occurrence est trouv√©e et si elle ne correspond pas exactement √† "text_changed"
    if (text_changed_pos && !g_str_has_suffix(text_changed_pos, text_changed)) {
        // Calculer la longueur de la partie √† modifier dans la ligne
        guint length = text_changed_pos - escamoted_line + strlen(text_changed)+1;
        gchar *spaces = g_strdup_printf("    üìé%*s ", length + 2, " ");
        // Copier les espaces dans la partie √† modifier de la ligne
        memcpy(escamoted_line, spaces, length);
        g_free(spaces);
    }
    return escamoted_line;
}

void launch(GtkWidget *widget, gpointer user_data) {
    GtkTreeView *treeview = GTK_TREE_VIEW(user_data);
    const char *pidFilename = "/home/sdethyre/sandbox/dash_dev_boisson/pid.txt";
    gboolean checked_vs   = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(check_vs))  ;
    gboolean checked_ti   = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(check_ti))  ;
    gboolean checked_job  = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(check_job)) ;
    gboolean checked_app  = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(check_app)) ;
    if      (checked_vs)    open_file(treeview, user_data)                             ;
    if      (checked_ti)    open_web_page(treeview, user_data, "open_ti.py" , combobox);
    if      (checked_job)   open_web_page(treeview, user_data, "open_job.py", combobox);
    if      (checked_app)   open_web_page(treeview, user_data, "open_app.py", combobox);
    generic_quit (treeview, pidFilename);
}

void select_row_at_index(GtkTreeView *treeview, int index) {
    // GtkTreeModel *model = gtk_tree_view_get_model(treeview);
    GtkTreeSelection *selection = gtk_tree_view_get_selection(treeview);

    // V√©rifier que l'index est valide
    if (index >= 0) {
        GtkTreePath *path = gtk_tree_path_new_from_indices(index, -1);
        // S√©lectionner la ligne en utilisant le GtkTreePath
        gtk_tree_selection_select_path(selection, path);
        // Lib√©rer la m√©moire du GtkTreePath
        gtk_tree_path_free(path);
    } 
   // else  printf("Index invalide");
}

void gtk_main_quit_te() {
    const char *pidFilename = "/home/sdethyre/sandbox/dash_dev_boisson/pid.txt";
    clear_file(pidFilename);
    gtk_main_quit();
}

void handle_close_signal(int signum) {
    if (window != NULL) {
        gtk_widget_destroy(GTK_WIDGET(window));
        gtk_main_quit_te();
    }
}

int get_first_instance_PID() {
    int pid = -1;
    FILE *file = fopen("/home/sdethyre/sandbox/dash_dev_boisson/pid.txt", "r");
    if (file != NULL) {
        fscanf(file, "%d", &pid);
        fclose(file);
    }
    return pid;
}

static void on_entry_clicked(GtkWidget *widget, gpointer data) {
    GtkCssProvider *provider = gtk_css_provider_new();
    gtk_css_provider_load_from_path(provider, "/home/sdethyre/sandbox/dash_dev_boisson/style.css", NULL);

    GtkStyleContext *context = gtk_widget_get_style_context(widget);
    gtk_style_context_add_provider(context, GTK_STYLE_PROVIDER(provider), GTK_STYLE_PROVIDER_PRIORITY_USER);
    gtk_style_context_add_class(context, "neon");
}

gboolean on_entry_focus_out(GtkWidget *widget, gpointer data) {
    GtkStyleContext *context = gtk_widget_get_style_context(widget);
    gtk_style_context_remove_class(context, "neon");
    return GDK_EVENT_PROPAGATE;
}

void connect_signals(GtkWidget *widget) {
    // connecter les signaux "enter-notify-event", "leave-notify-event", "focus-in-event" et "focus-out-event"
    g_signal_connect(widget, "enter-notify-event", G_CALLBACK(on_entry_clicked), NULL);
    g_signal_connect(widget, "leave-notify-event", G_CALLBACK(on_entry_focus_out), NULL);
    g_signal_connect(widget, "focus-in-event", G_CALLBACK(on_entry_clicked), NULL);
    g_signal_connect(widget, "focus-out-event", G_CALLBACK(on_entry_focus_out), NULL);
    g_signal_connect(widget, "motion-notify-event", G_CALLBACK(on_entry_clicked), NULL);
    // g_signal_connect(widget, "scroll-event", G_CALLBACK(on_entry_clicked), NULL);
    
    // si le widget est un conteneur, connecter les signaux √† ses enfants
    if (GTK_IS_CONTAINER(widget)) {
        GtkContainer *container = GTK_CONTAINER(widget);
        GList *children = gtk_container_get_children(container);
        GList *child;
        for (child = children; child != NULL; child = g_list_next(child)) {
            GtkWidget *child_widget = GTK_WIDGET(child->data);
            connect_signals(child_widget);
        }
        g_list_free(children);
    }
}

void connect_signals_on_widget(GtkWidget *widget) {
    connect_signals(GTK_WIDGET(widget));
}

int main(int argc, char *argv[]) {
    // Dimensions
    window_width = 550;
    number_of_devs = count_lines_in_file("/home/sdethyre/sandbox/dash_dev_boisson/results.txt");
    basic_height = 100 + 18 * number_of_devs;
    intern_minal_height = 300;

    if (is_instance_running()) {
        // Envoyer le signal SIGUSR1 √† la premi√®re instance
        int first_instance_pid = get_first_instance_PID();
        if (first_instance_pid != -1) {
            kill(first_instance_pid, SIGUSR1);
            g_spawn_command_line_async("/home/sdethyre/sandbox/dash_dev_boisson/dash_dev", NULL);
        return EXIT_SUCCESS;
        }
    }

    int current_pid = getpid(); // Obtenir le PID de l'application en cours d'ex√©cution
    save_PID_to_file(current_pid);

    char command[256];
    sprintf(command, "bash /home/sdethyre/sandbox/dash_dev_boisson/list_devs");
    int exit_status = system(command);

    if (exit_status == -1) {
        printf("Erreur lors de l'ex√©cution du script");
        return 1;
    }
    else if (!WIFEXITED(exit_status) || WEXITSTATUS(exit_status) != 0) {
        printf("Le script s'est termin√© avec une erreur");
        return 1;
    }
    gtk_init(&argc, &argv);

    // Cr√©er la fen√™tre principale
    window = GTK_WINDOW(gtk_window_new(GTK_WINDOW_TOPLEVEL));
    gtk_window_set_title(GTK_WINDOW(window), "Devs    üîß");
    gtk_window_set_default_size(GTK_WINDOW(window), window_width, basic_height);
    gtk_container_set_border_width(GTK_CONTAINER(window), 10);
    g_signal_connect(G_OBJECT(window), "destroy", G_CALLBACK(gtk_main_quit_te), NULL);
    gtk_window_move(GTK_WINDOW(window), 750, 300);
    
    // Cr√©er le mod√®le de donn√©es pour la liste
    GtkListStore *list_store = gtk_list_store_new(2, G_TYPE_STRING, G_TYPE_STRING);

    // Ouvrir le fichier "results.txt"
    char file_path[256];
    sprintf(file_path, "/home/sdethyre/sandbox/dash_dev_boisson/results.txt");
    FILE *file = fopen(file_path, "r");
    if (file) {
        char line[256];
        while (fgets(line, sizeof(line), file)) {
            // Suppression du saut de ligne √† la fin de la ligne
            line[strcspn(line, "\n")] = '\0';
            // V√©rifier que la ligne ne se termine pas par ".bak"
            gboolean is_valid_line = !g_str_has_suffix(line, ".bak");
            
            if (( g_str_has_prefix(line, "5") || g_str_has_prefix(line, "6") ) && is_valid_line) {
                gchar *escamoted_line = escamote_line(line, "develop");
                GtkTreeIter iter;
                // Ajouter une nouvelle ligne √† la liste GtkTreeStore
                gtk_list_store_append(list_store, &iter);
                // D√©finir les valeurs des colonnes de la nouvelle ligne
                gtk_list_store_set(list_store, &iter, 0, escamoted_line, 1, line, -1);
                g_free(escamoted_line);
            }
            else if (g_str_has_prefix(line, "refonte-graphique") && is_valid_line) {
                gchar *escamoted_line = escamote_line(line, "");
                gchar *title = "refonte-graphique";
                GtkTreeIter iter;
                gtk_list_store_append(list_store, &iter);
                gtk_list_store_set(list_store, &iter, 0, title, 1, escamoted_line, -1);
                g_free(escamoted_line);
            }
            else if (g_str_has_prefix(line, "rg-") && is_valid_line) {
                gchar *escamoted_line = escamote_line(line, "rg");
                gchar *indented_line = g_strdup_printf("    üé®    %s", escamoted_line);
                GtkTreeIter iter;
                gtk_list_store_append(list_store, &iter);
                gtk_list_store_set(list_store, &iter, 0, indented_line, 1, line, -1);
                g_free(escamoted_line);
                g_free(indented_line);
            }
        }
        fclose(file);
    }
    // Une ligne vide de + dans la liste
    GtkTreeIter blank_iter;
    gtk_list_store_append(list_store, &blank_iter);
    // D√©finir les valeurs des colonnes de la nouvelle ligne (en laissant les valeurs vides)
    gtk_list_store_set(list_store, &blank_iter, 0, "", 1, "", -1);

    // Cr√©er le GtkTreeView √† partir du mod√®le de donn√©es
    GtkWidget *treeview = gtk_tree_view_new_with_model(GTK_TREE_MODEL(list_store));
    g_object_unref(list_store);
    
    //‚ñ∂ ‚óÄ
    // Cr√©er une colonne pour afficher le texte
    GtkCellRenderer *renderer = gtk_cell_renderer_text_new();
    // GtkTreeViewColumn *column = gtk_tree_view_column_new_with_attributes("\n  < : Appli\t\t\t      ‚èé : VsCode\t\t\t\t Ctrl D : Test  \n  Alt Gr : Choix test\t\t\t     n : Nouveau\t\t\t\t     x : Quitter\n  ‚á¶ Debug\t\t\t\t\t‚îÅ‚îÅ : Tout\t\t\t\t\t   SVN ‚á® \n", renderer, "text", 0, NULL);
    GtkTreeViewColumn *column = gtk_tree_view_column_new_with_attributes("", renderer, "text", 0, NULL);
    gtk_tree_view_append_column(GTK_TREE_VIEW(treeview), column);

    // D√©finir la taille du GtkTreeView
    GtkRequisition requisition;
    gtk_widget_get_preferred_size(treeview, &requisition, NULL);
    requisition.width = 200; // Modifier la largeur souhait√©e
    gtk_widget_set_size_request(treeview, requisition.width, requisition.height);

    // Cr√©er la s√©lection pour le GtkTreeView
    GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(treeview));
    gtk_tree_selection_set_mode(selection, GTK_SELECTION_SINGLE);

    gchar *current_dev = recuperer_elements_droite_string("/home/sdethyre/sandbox/dash_dev_boisson/config.txt", "current_dev:");
    select_row_at_index(GTK_TREE_VIEW(treeview), atoi(current_dev));

    // Connecter l'√©v√©nement de s√©lection au callback "open_file"
    g_signal_connect(G_OBJECT(treeview), "row-activated", G_CALLBACK(open_file), combobox);

    // Connecter l'√©v√©nement de pression des touches du clavier au callback "on_treeview_key_press"
    g_signal_connect(G_OBJECT(treeview), "key-press-event", G_CALLBACK(on_treeview_key_press), NULL);

    // Cr√©er le conteneur vertical (vbox)
    GtkWidget *vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 5);

    // 3 * 3
    // Cr√©er les √©tiquettes
    GtkWidget *label1 = gtk_label_new("< : Appli");
    GtkWidget *label2 = gtk_label_new("‚èé : VsCode");
    GtkWidget *label3 = gtk_label_new("Ctrl D : Test");
    GtkWidget *label4 = gtk_label_new("x : Quitter");
    GtkWidget *label5 = gtk_label_new("n : Nouveau");
    GtkWidget *label6 = gtk_label_new("Alt Gr : Choix test");
    GtkWidget *label7 = gtk_label_new("‚á¶ Debug");
    GtkWidget *label8 = gtk_label_new("‚îÅ‚îÅ : Tout");
    GtkWidget *label9 = gtk_label_new("SVN ‚á®");

    gtk_label_set_xalign (GTK_LABEL(label1), -1);
    gtk_label_set_xalign (GTK_LABEL(label4), -1);
    gtk_label_set_xalign (GTK_LABEL(label7), -1);
    gtk_label_set_xalign (GTK_LABEL(label3), 1);
    gtk_label_set_xalign (GTK_LABEL(label6), 1);
    gtk_label_set_xalign (GTK_LABEL(label9), 1);

    // Cr√©er un conteneur de grille pour organiser les √©tiquettes en 3x3
    GtkWidget *labels_grid = gtk_grid_new();
    gtk_grid_set_column_homogeneous(GTK_GRID(labels_grid), TRUE); // R√©partir l'espace √©galement entre les colonnes

    // Ajouter les √©tiquettes √† la grille
    gtk_grid_attach(GTK_GRID(labels_grid), label1, 0, 0, 1, 1);
    gtk_grid_attach(GTK_GRID(labels_grid), label2, 1, 0, 1, 1);
    gtk_grid_attach(GTK_GRID(labels_grid), label3, 2, 0, 1, 1);
    gtk_grid_attach(GTK_GRID(labels_grid), label4, 0, 1, 1, 1);
    gtk_grid_attach(GTK_GRID(labels_grid), label5, 1, 1, 1, 1);
    gtk_grid_attach(GTK_GRID(labels_grid), label6, 2, 1, 1, 1);
    gtk_grid_attach(GTK_GRID(labels_grid), label7, 0, 2, 1, 1);
    gtk_grid_attach(GTK_GRID(labels_grid), label8, 1, 2, 1, 1);
    gtk_grid_attach(GTK_GRID(labels_grid), label9, 2, 2, 1, 1);

    // Ajouter la grille au d√©but du vbox
    gtk_box_pack_start(GTK_BOX(vbox), labels_grid, FALSE, FALSE, 10); // Ajuster les marges selon vos pr√©f√©rences

    // Cr√©er le GtkComboBox avec les valeurs pr√©d√©finies et un champ d'entr√©e
    const gchar* combo_values[] = {"admin", "instr", "instrpoly", "admingen", "agmingenmars", "guichet", "guichetsuivi", "assist", "oaamb"};
    const int num_versions = sizeof(combo_values) / sizeof(combo_values[0]);
    combobox = gtk_combo_box_text_new_with_entry();
    GtkWidget *entry = gtk_bin_get_child(GTK_BIN(combobox));
    gtk_entry_set_placeholder_text(GTK_ENTRY(entry), "admin");
    for (int i = 0; i < num_versions; i++) { gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(combobox), combo_values[i]); }
    gtk_combo_box_set_entry_text_column(GTK_COMBO_BOX(combobox), 0);
    gtk_widget_set_tooltip_text(combobox, "Utilisateur de l'application (admin par d√©faut)");

    // Ajouter le GtkComboBox et le GtkTreeView au vbox
    gtk_container_add(GTK_CONTAINER(vbox), treeview);

    // Cr√©ation de l'espace visuel entre la grille et le bouton
    GtkWidget *separator = gtk_separator_new(GTK_ORIENTATION_HORIZONTAL);
    gtk_widget_set_hexpand(separator, TRUE);
    gtk_container_add(GTK_CONTAINER(vbox), separator);

    gtk_container_add(GTK_CONTAINER(vbox), GTK_WIDGET(combobox));

    // Cr√©ation du conteneur GtkBox pour centrer le grid
    GtkWidget *box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);
    gtk_widget_set_halign(box, GTK_ALIGN_CENTER);
    gtk_widget_set_valign(box, GTK_ALIGN_CENTER);
    gtk_box_pack_start(GTK_BOX(vbox), box, TRUE, TRUE, 0);

    // Cr√©ation de la grille
    GtkWidget *grid = gtk_grid_new();
    gtk_widget_set_margin_top(grid, 10);
    gtk_grid_set_row_spacing(GTK_GRID(grid), 10);
    gtk_grid_set_column_spacing(GTK_GRID(grid), 10);
    gtk_container_add(GTK_CONTAINER(box), grid);

    // Add the checkboxes in two rows with two checkboxes per row
    check_vs = gtk_check_button_new_with_label("VsCode");
    gtk_grid_attach(GTK_GRID(grid), check_vs, 0, 2, 1, 1);
    check_ti = gtk_check_button_new_with_label("Ticket Interne");
    gtk_grid_attach(GTK_GRID(grid), check_ti, 1, 2, 1, 1);
    check_job = gtk_check_button_new_with_label("Job Jenkins");
    gtk_grid_attach(GTK_GRID(grid), check_job, 0, 3, 1, 1);
    check_app = gtk_check_button_new_with_label("Application");
    gtk_grid_attach(GTK_GRID(grid), check_app, 1, 3, 1, 1);

    // The "Modifi√©s" label and the new "Init" check button in a separate row with a slight right offset
    counter_label = gtk_label_new("w : infos");
    gtk_grid_attach(GTK_GRID(grid), counter_label, 0, 1, 1, 1);
    gtk_widget_set_margin_start(counter_label, 130); // Adjust the value as needed

    // check_init = gtk_check_button_new_with_label("Init");
    // gtk_grid_attach(GTK_GRID(grid), check_init, 1, 4, 1, 1);
    // gtk_widget_set_margin_start(check_init, 30);

    // After connecting "row-activated" signal for treeview selection
    // GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(treeview));

    gtk_tree_selection_set_mode(selection, GTK_SELECTION_SINGLE);
    g_signal_connect(G_OBJECT(treeview), "row-activated", G_CALLBACK(open_file), combobox);
    // g_signal_connect(G_OBJECT(selection), "changed", G_CALLBACK(update_counter_label), NULL);
    g_signal_connect(G_OBJECT(selection), "changed", G_CALLBACK(on_selection_changed), NULL);
    key_press_handler_id = g_signal_connect(treeview, "key-press-event", G_CALLBACK(on_treeview_key_press), NULL);
    g_signal_connect(G_OBJECT(treeview), "button-press-event", G_CALLBACK(on_right_click), NULL);

    GtkWidget *button = gtk_button_new_with_label("Ouvrir");
    gtk_container_add(GTK_CONTAINER(vbox), button);
    g_signal_connect(button, "clicked", G_CALLBACK(launch), treeview);
    //‚ñºÀÖ‚åÑ
    terminal_button = GTK_BUTTON(gtk_button_new_with_label("‚ñº"));
    gtk_container_add(GTK_CONTAINER(vbox), GTK_WIDGET(terminal_button));

    scrolled_window = gtk_scrolled_window_new(NULL, NULL);
    g_signal_connect(terminal_button, "clicked", G_CALLBACK(toggle_intern_minal_height), scrolled_window);
    g_signal_connect(terminal_button, "clicked", G_CALLBACK(toggle_window_height_at_bottom), window);
    signal(SIGUSR1, handle_close_signal);

    // Create a GtkTextView for displaying the output
    output_text_view = gtk_text_view_new();
    gtk_text_view_set_editable(GTK_TEXT_VIEW(output_text_view), FALSE);
    gtk_text_view_set_cursor_visible(GTK_TEXT_VIEW(output_text_view), FALSE);
    // Add the GtkTextView to the GtkScrolledWindow
    gtk_container_add(GTK_CONTAINER(scrolled_window), output_text_view);

    // Create a GtkBox to hold the GtkScrolledWindow and the GtkButton
    GtkWidget *box_w = gtk_box_new(GTK_ORIENTATION_VERTICAL, 5);
    gtk_box_pack_start(GTK_BOX(box_w), scrolled_window, TRUE, TRUE, 0);

    // connect_signals_on_widget(GTK_WIDGET(scrolled_window));

    // Add the GtkBox to the GtkWindow
    gtk_container_add(GTK_CONTAINER(vbox), box_w);

    gtk_container_add(GTK_CONTAINER(window), vbox);

    // connect_signals_on_widget(GTK_WIDGET(dev_name));

    // gtk_widget_show_all(window);
    gtk_widget_show_all(GTK_WIDGET(window));

    gtk_widget_hide(scrolled_window);

    save_current_dev(GTK_TREE_VIEW(treeview));
    gtk_main();
    unlink(LOCK_FILE);
    return 0;
}
